#!/bin/tcsh
#

# Used to call the L2 pipeline installed Nov 2014 

# Hard coded to reject any arc lamps other than Xe

# TABLE OF POSSIBLE RETURNS OF THIS SCRIPT
# ----------------------------------------
# 0	Success. No error.
# 1	Command line syntax error
# 2	Could not move to data directory. Unknown reason.
# 3	Could not move to data directory. Directory does not exist.
# 4	Script invoked by non data user
# 5	Failed to establish lock file after five attempts
# 6	Unknown error in lockfile subsystem
#
# 99	Unknown error. Probably you pressed ^C.
# ----------------------------------------
set exit_value = 0

#               __ _      
#  __ ___ _ _  / _(_)__ _ 
# / _/ _ \ ' \|  _| / _` |
# \__\___/_||_|_| |_\__, |
#                   |___/ 
#

set instrum = sprat
set letter = v

set DEBUG = 1

source /usr/local/bin/${instrum}_l2_pipeline_debug/scripts/L2_setup
# Having sourced this, the script to call is now aliased to l2exec

set FGKV = /usr/local/bin/fits_get_keyword_value_static
set FAKV = /usr/local/bin/fits_add_keyword_value_static
set FAKVC = /usr/local/bin/fits_add_keyword_value_comment_static
set FGH = /usr/local/bin/fits_get_header_static
set AWK = /bin/awk
set MAGICK_CONVERT = /usr/bin/convert
set SEx = /usr/bin/sex

# Uses a subroutine which needs to be on the path
set SUB2 = /usr/local/bin/${instrum}_l2v2_wrapper_par_sub2_debug.csh 


set HOSTNAME = `hostname -s`
set procname = ${instrum}_l2v2_wrapper
alias datestamp "/bin/date -u +'%Y-%m-%dT%H:%M:%S %Z'"

set DPRT_BASEDIR = /data/Dprt


#  _ __  __ _ _ _ ___ ___   __ _ _ _ __ _ ___
# | '_ \/ _` | '_(_-</ -_) / _` | '_/ _` (_-<
# | .__/\__,_|_| /__/\___| \__,_|_| \__, /__/
# |_|                               |___/    

if ("$1" == "-v" ) then
  echo "Debug mode"
  set DEBUG = 1
  shift
endif

switch (${#argv})
    case 1:
      if ($DEBUG) echo `datestamp` $HOSTNAME $procname : Target WORKING_DIR = $1
      set WORKING_DIR = $1
    breaksw
    default:
      echo "Usage: ${instrum}_l2v2_wrapper.csh [-v] <path>"
      echo "	-v	Optional verbose output to console. If present, it must be first parameter."
      echo "    <path> is fully qualified path to directory containing the L1 files to be processed."
      exit 1
endsw


# ------------------------- #
# MOVE TO WORKING DIRECTORY #
# ------------------------- #
# We operate from within the working directory
# Though it is not a big deal, it makes parsing filenames a lot easier if you don't need to keep stripping the path
if ( -d "$WORKING_DIR" ) then
  cd $WORKING_DIR
  #if ( "$PWD" != "$WORKING_DIR" ) then
  #  echo `datestamp` $HOSTNAME $procname : "Failed to change to working directory ${WORKING_DIR}. Did you use a fully qualified path in the command line?"
  #  exit 2
  #else
    if ($DEBUG) echo `datestamp` $HOSTNAME $procname : Working in $PWD 
  #endif  
else
  echo `datestamp` $HOSTNAME $procname : "Directory (${WORKING_DIR}) does not exist. No L2 pipeline run "
  exit 3
endif


set LOGFILE = ${procname}_log.`date -u +%Y%m%d%H%M%S`
touch $LOGFILE
echo "`datestamp` $HOSTNAME $procname : First line of logfile" >> $LOGFILE



# -------------#
# SAFETY CHECK #
# -------------#
# This script is only supposed to be run as user data
if ( "$USER" != "data" ) then
  echo "`datestamp` $HOSTNAME $procname : This script is only allowed to run as user data." | tee -a $LOGFILE 
  echo "`datestamp` $HOSTNAME $procname : Please log out of the $USER  account, log in as data and try again" | tee -a $LOGFILE
  exit 4
endif


#  _         _      __ _ _               _       _      
# | |___  __| |__  / _(_) |___   __ _ __| |_ __ (_)_ _  
# | / _ \/ _| / / |  _| | / -_) / _` / _` | '  \| | ' \ 
# |_\___/\__|_\_\ |_| |_|_\___| \__,_\__,_|_|_|_|_|_||_|

# Let both versions of the pipeline share lock files so that we cannot run
# both at the same time.
set THREAD_COUNT = 4
set THREAD_LOCK = /var/tmp/run_${instrum}_l2_thread_lock.


# ------------------ #
# SET LOCK FILE NAME #
# ------------------ #
set lock = /var/tmp/run_${instrum}_l2.lock
set lockattempts = 0

createlockfile:
# ---------------- #
# CREATE LOCK FILE #
# ---------------- #
umask 333
echo "`datestamp` $HOSTNAME $procname : Creating lock file"
nohup echo $$ > $lock
# First see if creating the lock worked
if ($status != 0) then
    echo "`datestamp` $HOSTNAME $procname : Creation of lock file failed"
    # Next see if the problem is an orphan lock file languishing in /tmp
    if ( -e $lock ) then
      echo "`datestamp` $HOSTNAME $procname : Lock file exists. Looking at contents"
      ps -elf | grep $procname | grep `cat $lock`
      if($? == 0) then
        echo "`datestamp` $HOSTNAME $procname : By running ps it looks like a $procname is underway. Not starting a new instance."
        if ($lockattempts > 5) then
          echo "`datestamp` $HOSTNAME $procname : Made five attempts to get the lock file. Giving up."
          exit 5
	else
          echo "`datestamp` $HOSTNAME $procname : Sleeping one minute and will try again."
	  @ lockattempts++
          sleep 60
	  goto createlockfile
	endif
      else
        echo "`datestamp` $HOSTNAME $procname : By running ps it looks like this is an out of date lock file. It will be deleted and $procname will proceed."
        rm -f $lock
	goto createlockfile
      endif
    else
      echo "`datestamp` $HOSTNAME $procname : Unexplained error. Lock file creation failed, but there is no lock file at $lock"
      exit 6
    endif
endif
umask 22

# A lock file now exists, so any future errors should cleanup before
# exiting the script. This will set the exit code to 99, clean up any lock files and exit
onintr unknown_error

# Now that the script's master lock file is established we can safely delete any 
# individual thread locks. They must be left over from another run.
set counter = 1
while ($counter <= $THREAD_COUNT)
  if (-e ${THREAD_LOCK}$counter) rm -f ${THREAD_LOCK}$counter
  @ counter++
end


echo "`datestamp` $HOSTNAME $procname : End of lockfile admin"

################################################
# Create config files to be used by SExtractor #
################################################
echo "479 179"				>! v_magicpixelfile # Specied here unbinned	SPRAT
echo "2161 2058"			>! h_magicpixelfile # Specied here unbinned	IOO
echo "479 179"				>! q_magicpixelfile # Specied here unbinned     RISE

echo "CATALOG_NAME     test.cat       " >! default.sex 
echo "CATALOG_TYPE     ASCII_HEAD     " >> default.sex
echo "PARAMETERS_NAME  default.param  " >> default.sex 
echo "DETECT_TYPE      CCD            " >> default.sex 
echo "DETECT_MINAREA   5              " >> default.sex 
echo "THRESH_TYPE      RELATIVE       " >> default.sex 
echo "DETECT_THRESH    3.0            " >> default.sex 
echo "ANALYSIS_THRESH  1.5            " >> default.sex 
echo "FILTER           N              " >> default.sex 
echo "DEBLEND_NTHRESH  32             " >> default.sex 
echo "DEBLEND_MINCONT  0.002          " >> default.sex 
echo "PHOT_APERTURES   6              " >> default.sex 
echo "BACK_TYPE        AUTO           " >> default.sex 
echo "BACK_SIZE        64             " >> default.sex 
echo "BACK_FILTERSIZE  3              " >> default.sex 
echo "BACKPHOTO_TYPE   LOCAL          " >> default.sex 
echo "CHECKIMAGE_TYPE  NONE           " >> default.sex 
echo "ASSOC_NAME       _MAGICPIXFILE_ " >> default.sex
echo "ASSOC_DATA       0              " >> default.sex
echo "ASSOC_PARAMS     1,2            " >> default.sex
# XXX Even at 5pix I have had the target not found. I have seen frames where star was 6pix along the slit.
echo "ASSOC_RADIUS     5.0            " >> default.sex
echo "ASSOC_TYPE       NEAREST        " >> default.sex
echo "ASSOCSELEC_TYPE  MATCHED        " >> default.sex

echo "NUMBER		        " >! default.param
echo "FLUX_APER[1]		" >> default.param
echo "FLUX_AUTO			" >> default.param
echo "XWIN_IMAGE		" >> default.param
echo "YWIN_IMAGE		" >> default.param
echo "AWIN_IMAGE		" >> default.param
echo "BWIN_IMAGE		" >> default.param
echo "FLAGS		        " >> default.param
echo "VECTOR_ASSOC[1]		" >> default.param
echo "VECTOR_ASSOC[2]		" >> default.param
echo "NUMBER_ASSOC		" >> default.param





# SPRAT has v_e_ files that may be images, slit images, spectra or slitless spectra.
# We only handle the slit spectra in L2, so we need to build a list of them
# First we can exit if there are none and second we will want this list later. 
set count_spectra = 0
if ( -e ${instrum}_spec_list ) rm ${instrum}_spec_list
touch ${instrum}_spec_list

# We might call this script on either L1 files or L9 quicklook files. 
# If there are any v_e_*_1.fits files present then we assume this is a full morning reduction
# If there are no v_e_*_1.fits then we will see if there are any v_e_*_9.fits
set RED_LEVEL = x
if ( `echo  ${letter}_[es]_20*_1.fits |& grep -i -v "No match" | tr " " "\n" | wc -l` ) then
  # Full L1 -> L2 reduction
  set RED_LEVEL = 1
  if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Selected L1 mode " >> $LOGFILE
else if ( `echo  ${letter}_[es]_20*_9.fits |& grep -i -v "No match" | tr " " "\n" | wc -l` ) then
  # Quicklook reduction
  if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Selected L9 mode" >> $LOGFILE
  set RED_LEVEL = 9
endif

if ( `echo  ${letter}_[es]_20*_${RED_LEVEL}.fits |& grep -i -v "No match" | tr " " "\n" | wc -l` ) then
  foreach fn ( ${letter}_[es]_20*_${RED_LEVEL}.fits )
    set slitpos = `$FGKV $fn SLITPOS STRING |& grep -iv 'not found'`
    set gratpos = `$FGKV $fn GRATPOS STRING |& grep -iv 'not found'`
    #if ($DEBUG) echo $fn $slitpos $gratpos
    if ( "$slitpos" == "IN" && "$gratpos" == "IN" ) then
      @ count_spectra++
      echo $fn >> ${instrum}_spec_list 
    endif
  end
endif
#if ($DEBUG) then
#  echo "`datestamp` $HOSTNAME $procname : Contents of ${instrum}_spec_list..."
#  cat ${instrum}_spec_list
#endif


if ( $count_spectra == 0 ) then
  echo "`datestamp` $HOSTNAME $procname : There are no ${letter}_[es] files in $WORKING_DIR to process." >> $LOGFILE
  if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : There are no ${letter}_[es] files in $WORKING_DIR to process."
  set exit_value = 0
  goto cleanup
endif

# Now do that all again for v_[aw]_ files. Again we need a list that contains
# only slit spectra and reject any slitless spectra or slit images.
set count_arcs = 0
if ( -e ${instrum}_arc_list ) rm ${instrum}_arc_list
touch ${instrum}_arc_list
if ( `echo  ${letter}_[aw]_20*1.fits |& grep -i -v "No match" | tr " " "\n" | wc -l` ) then
  foreach fn ( ${letter}_[aw]_20*1.fits )
    set slitpos = `$FGKV $fn SLITPOS STRING |& grep -iv 'not found'`
    set gratpos = `$FGKV $fn GRATPOS STRING |& grep -iv 'not found'`
    if ( "$slitpos" == "IN" && "$gratpos" == "IN" ) then
      @ count_spectra++
      echo $fn >> ${instrum}_arc_list 
    endif
  end
endif

# ------------------- #
# Copy CAT-RA into RA #
# ------------------- #
# It has been agreed that we will summararily change the FITS header values in
# RA,DEC which are derived from RATCam so that they are simply copies of
# what is in CAT-RA,CAT-DEC since assuming the acquisition succeeded, that is 
# indeed where the telescope is pointing the spectrograph input. The biggest reason we want to
# do this is to leave the L0 file as an accurate copy of what is read raw from the
# telescope but we want the RA,DEC as stored in the data archive to be the 
# target RA,DEC not the telecsope TPOINT RA,DEC. That is more use to observers.
#
# Whether RA,DEC are correct in the header depends on use of TWEAK vs OFFBY in the 
# acquisition phase. Since this has been changed recently this stop may not longer be
# required or may be more vital. To be checked.
#
# So this does nothing more exciting than copy CAT-RA -> RA and CAT-DEC -> DEC

foreach fn (`cat ${instrum}_spec_list | tr "\n" " " ` )
  # Careful about reference system here. Currently RA,DEC is always 
  # written in FK5 J2000 but CAT-RA,CAT-DEC could be several things.
  
  # Make sure that both CAT-EQUI and CAT-EPOC are 2000
  # If they are not then we cannot just transcribe
  # awk is being used here to do the comparison of floats since csh only does integers
  set catequi_2000 = `$FGKV $fn CAT-EQUI DOUBLE | $AWK '($1==2000){print "2000"}'`
  set catepoc_2000 = `$FGKV $fn CAT-EPOC DOUBLE | $AWK '($1==2000){print "2000"}'`
  if ( ("$catequi_2000" == "2000") && ("$catepoc_2000" == "2000") ) then
    $FAKV $fn RA STRING "`$FGKV $fn CAT-RA STRING`"
    $FAKV $fn DEC STRING "`$FGKV $fn CAT-DEC STRING`"
  else
    echo "`datestamp` $HOSTNAME $procname : $fn CAT-RA, CAT-DEC are not FK5 so we cannot fix up the RA,DEC headers" >> $LOGFILE
    echo "`datestamp` $HOSTNAME $procname : $fn CAT-RA, CAT-DEC are not FK5 so we cannot fix up the RA,DEC headers"
  endif
end

# ------------------------------------------------------ #
# Add name of final acquisition image to spectra headers #
# ------------------------------------------------------ #
#
echo ?_q_20*_1.fits |& grep -iv "no match"  >! ${instrum}_acq_list
if (-e ${instrum}_acq_list2) rm ${instrum}_acq_list2
# First read GRPUID from all the acquisition images
if (`cat ${instrum}_acq_list | wc -w `) then
  foreach fn (`cat ${instrum}_acq_list ` )
    #if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Find grpuid image for $fn"
    set grpuid = `$FGKV $fn GRPUID INT `
    set mjd = `$FGKV $fn MJD DOUBLE `
    echo $fn $grpuid $mjd >> ${instrum}_acq_list2
  end
  sort -k 3 -n ${instrum}_acq_list2 >! ${instrum}_acq_list

  # Then match up to the same GRPUID in the spectrum FITS
  foreach fn (`cat ${instrum}_spec_list | tr "\n" " " ` )
    set grpuid = `$FGKV $fn GRPUID INT `
    set mjd = `$FGKV $fn MJD DOUBLE `
    set final_acq = `awk '( ($2=='$grpuid') && ($3<'$mjd') ){print $1}' ${instrum}_acq_list | tail -1`

    # If ACQIMAGE was already set in a previous run, we can use that.
    # This is not generally going to happen, but is useful during testing. Note that we always
    # give preference to a newly determined ACQIMAGE if available and fall back to checking
    # the FITSheader only as a backup.
    if ("$final_acq" == "") set final_acq = `$FGKV $fn ACQIMAGE STRING`

    if ("$final_acq" == "") then
      echo "`datestamp` $HOSTNAME $procname : Unable to identify acq image for $fn" >> $LOGFILE
      echo "`datestamp` $HOSTNAME $procname : Unable to identify acq image for $fn" 
    else
      if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Process acq image ($final_acq) used for $fn" 
                  echo "`datestamp` $HOSTNAME $procname : Process acq image ($final_acq) used for $fn" >> $LOGFILE

      $FAKVC $fn ACQIMAGE STRING $final_acq "" "Final acquisition image"

      set acq_inst = `echo $final_acq | cut -d_ -f1`

      # RCS magic pixels are stored unbinned. Rescale by CCDXBIN to get the coordinate in this image
      set acq_binning = `$FGKV $final_acq CCDXBIN INT`
      awk '{print $1/'$acq_binning',$2/'$acq_binning'}' ${acq_inst}_magicpixelfile >! ${acq_inst}_magicpixelfile_bin

      set exptime = `$FGKV $final_acq EXPTIME DOUBLE`

      # XXX If acquisition camera is not SPRAT then the photometry will need rescaleing by the gain of the other camera.
      # XXX Also need to restrict the section of spec_ss that read to match the filter of the acquisityion camera.

      cat default.sex | sed 's/_MAGICPIXFILE_/'${acq_inst}'_magicpixelfile_bin/' >! thisrun.sex
      echo "`datestamp` $HOSTNAME $procname : Run photometry on $final_acq "
      $SEx -c thisrun.sex $final_acq >>& $LOGFILE
      switch (`grep -vc "#" test.cat`)
        case 1:
	  set SEx_FLUX_APER_COL = `awk '(/FLUX_APER/) {print $2}' test.cat `
	  set SEx_FLUX_AUTO_COL = `awk '(/FLUX_AUTO/) {print $2}' test.cat `
	  set SEx_XWIN_IMAGE_COL = `awk '(/XWIN_IMAGE/) {print $2}' test.cat `
	  set SEx_YWIN_IMAGE_COL = `awk '(/YWIN_IMAGE/) {print $2}' test.cat `
	  set SEx_FLAGS_COL = `awk '(/FLAGS/) {print $2}' test.cat `
	  set SEx_NUMBER_ASSOC_COL = `awk '(/NUMBER_ASSOC/) {print $2}' test.cat `
	  $FAKVC $fn ACQFAPER DOUBLE `awk '(! /#/) {print $'$SEx_FLUX_APER_COL'/'$exptime'}' test.cat ` "ADU/sec" "Target brightness in acq. image"
	  $FAKVC $fn ACQFAUTO DOUBLE `awk '(! /#/) {print $'$SEx_FLUX_AUTO_COL'/'$exptime'}' test.cat ` "ADU/sec" "Target brightness in acq. image"
	  $FAKVC $fn ACQ_XIMG DOUBLE `awk '(! /#/) {print $'$SEx_XWIN_IMAGE_COL'}' test.cat ` "" "X coordinate in acq. image"
	  $FAKVC $fn ACQ_YIMG DOUBLE `awk '(! /#/) {print $'$SEx_YWIN_IMAGE_COL'}' test.cat ` "" "Y coordinate in acq. image"
	  $FAKVC $fn ACQFLAGS INT `awk '(! /#/) {print $'$SEx_FLAGS_COL'}' test.cat `	"" "SExtractor flags"
	  $FAKVC $fn ACQNASSC INT `awk '(! /#/) {print $'$SEx_NUMBER_ASSOC_COL'}' test.cat ` "" "Count of associated sources"
          breaksw
        case 0:
	  echo "`datestamp` $HOSTNAME $procname : No object found at magic pixel. Phot not possible." 
	  echo "`datestamp` $HOSTNAME $procname : No object found at magic pixel. Phot not possible." >> $LOGFILE
          breaksw
        default:
	  set SEx_NUMBER_ASSOC_COL = `awk '(/NUMBER_ASSOC/) {print $2}' test.cat `
	  $FAKVC $fn ACQNASSC INT `awk '(! /#/) {print $'$SEx_NUMBER_ASSOC_COL'}' test.cat ` "" "Count of associated sources"
	  echo "`datestamp` $HOSTNAME $procname : Multiple objects found at magic pixel. Phot not possible." 
	  echo "`datestamp` $HOSTNAME $procname : Multiple objects found at magic pixel. Phot not possible." >> $LOGFILE
          breaksw
      endsw
    endif

  end

  rm ${instrum}_acq_list

else
  echo "`datestamp` $HOSTNAME $procname : No acquisition images found. Not updating FITS headers" >> $LOGFILE
endif


# --------------------------------------------- #
# BUILD TABLE OF ALL THE RELEVANT FITS KEYWORDS #
# --------------------------------------------- #

if (-e ${instrum}_l2v2_input_list_1) rm -f ${instrum}_l2v2_input_list_1
if (-e ${instrum}_run_list) rm -f ${instrum}_run_list


# We already exited above if there are no [es] science frames to work on, but for the data table we want all
# the frames, includings arcs etc. The things we do however want to exclude are slitless spectra and 
# slit images
#
# This list is constucted from 
# 	slit spectra as provided by ${instrum}_spec_list. These are science data
# 	slit spectra of arcs (Xe or W) as provided by ${instrum}_arc_list.
# 	library arcs
# 	library wlamp spectra 
# 	library reference (reference science spectra for mapping optical distortion)
# We include the files in the DpRT library here in order that we will fall back on them if there is 
# nothing else to use
echo "`datestamp` $HOSTNAME $procname : Scanning directory to identify arcs. (Also the Dprt library.)" >> $LOGFILE
foreach fn ( `cat ${instrum}_spec_list | tr "\n" " " ` `cat ${instrum}_arc_list | tr "\n" " " ` ${DPRT_BASEDIR}/${instrum}/Arc/v_xearc_{red,blue}_[12].fits ${DPRT_BASEDIR}/${instrum}/Continuum/${letter}_continuum_{red,blue}_[12].fits ${DPRT_BASEDIR}/${instrum}/Reference/${letter}_reference_{red,blue}_[12].fits )
  if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Consider $fn for inclusion in ${instrum}_l2v2_input_list_1" | tee -a $LOGFILE
  set mjd = `$FGKV $fn MJD STRING` 
  set configid = `$FGKV $fn CONFIGID STRING` 
  set grpuid = `$FGKV $fn GRPUID STRING` 
  set gratset = `$FGKV $fn GRATSET STRING`
  set dateobs = `$FGKV $fn DATE-OBS STRING` 
  set gratid = `$FGKV $fn GRATID STRING`

  # Currently we only support symmetrical binning so no need to keep X and Y separately
  set ccdxbin = `$FGKV $fn CCDXBIN STRING`
  set ccdybin = `$FGKV $fn CCDYBIN STRING`
  set binning = $ccdxbin

  # We need to know which arc lamps were on. This is complicated.
  # Use fits_get_header to extract all the LAMP* keywords.
  # Extract from the list any that are switched on. I.e., set to "T"
  # For those that were T, we can then get the lamp name from the header and add that to a list
  #	of lamps which are on.
  set lamps = " "
  $FGH $fn >! ${instrum}_lamplist
  $AWK '($2=="T")' ${instrum}_lamplist >! ${instrum}_lamponlist
  set lamponcount = `cat ${instrum}_lamponlist | wc -l`
  if ($DEBUG) cat ${instrum}_lamponlist | tee -a $LOGFILE
  if ($lamponcount == 0) then
    echo "`datestamp` $HOSTNAME $procname : $fn No lamps on for this exposure. Not an arc." >> $LOGFILE
    set lamps = "-"
  else
    echo "`datestamp` $HOSTNAME $procname : $fn There is(are) $lamponcount lamp(s) swithed on." >> $LOGFILE
    foreach onlampset (`cat ${instrum}_lamponlist | sed 's/=.*//' | tr "\n" " "`)		# Keep just what is before the first =
      set onlamptyp = `echo $onlampset | sed 's/SET$/TYP/'`			# Swap SET for TYP
      set onlampname = `$FGKV $fn $onlamptyp STRING`				# Get the TYP from the FITS
      set lamps = ${lamps}${onlampname}						# Append to the list
    end
    echo "`datestamp` $HOSTNAME $procname :		$lamps" >> $LOGFILE
  endif
  rm -f ${instrum}_lamplist ${instrum}_lamponlist

  # These keywords are used, but not critical. We can do without them so they do not cause a reduction error 
  if ("$dateobs" == "") set dateobs = UNKNOWN
  if ("$gratid" == "") set gratid = UNKNOWN

  # These are critical and if thay are missing we do not continue
  if ( ("$mjd" == "") || ("$configid" == "") || ("$grpuid" == "") || ("$binning" == "") ) then
    echo "`datestamp` $HOSTNAME $procname : Error reading FITS keys from $fn. File will not be used." | tee -a $LOGFILE
    echo "`datestamp` $HOSTNAME $procname : Critical list is mjd,configid,grpuid,ccdxbin,ccdybin. May be missing?" | tee -a $LOGFILE
  else
    echo $fn $gratset $dateobs $mjd $configid $grpuid $gratid $binning $lamps >> ${instrum}_l2v2_input_list_1
  endif
end



# The subroutine needs to inherit
#	LOGFILE
#	DEBUG
# This is the subroutine which actually matches up science frames with the best available arc.
# Placing it in this external subroutite allows it to also be called from within the parallelized loop
# without disrupting the flow of the present script.
#
# By not setting a third command line parameter we process all files in this directory
$SUB2 1 $LOGFILE $DEBUG





echo "`datestamp` $HOSTNAME $procname : Following is first draft list of commands to be sent to the L2 pipeline:" >> $LOGFILE
cat ${instrum}_run_list >> $LOGFILE

# Now actually execute the commands in ${instrum}_run_list
set run_ct = `cat ${instrum}_run_list | wc -l`
if ($run_ct) then

  set run_list_line = 0
  while ($run_list_line <= $run_ct) 
    @ run_list_line++
    if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Start looking for thread for ${instrum}_run_list line $run_list_line" | tee -a $LOGFILE

    # Start of parallelized code
    #
    # The parallelized code gets complicated. It's not really what csh was invented for!
    # We ended up with this solution when the first prototype (STARLINK) frodo L2 pipeline took several minute per frame
    # Since it was all recoded in native C it became fast enough that maybe we don't need parallel processing any more.
    set counter = 1
    while ( $counter <= $THREAD_COUNT)
      lockfile -0 -r 0 ${THREAD_LOCK}$counter >& /dev/null
      if ( $? == 0 ) then   # Lockfile was created, so we may proceed to work
        set this_thread = $counter

	# Until the final job is finished we do not know whether it will fail and hence whether another
	# loop will be required. The upshot is that at the end of the run, we will always get to this point and 
	# find the ${instrum}_run_list finished.
        set run_ct = `cat ${instrum}_run_list | wc -l`
	if ($run_list_line > $run_ct) then

	  if($DEBUG) echo `datestamp`" $HOSTNAME $procname : Overshot end of ${instrum}_run_list. We must wait until all jobs are finished" | tee -a $LOGFILE
	  if($DEBUG) echo `datestamp`" $HOSTNAME $procname : 	before we know if any more repeats will be required." | tee -a $LOGFILE
	  set tmpcounter = 1
	  while ( $tmpcounter <= $THREAD_COUNT)
  	    if ($tmpcounter != $this_thread) then
	      lockfile -s1 -r-1 ${THREAD_LOCK}$tmpcounter
  	      rm -f ${THREAD_LOCK}$tmpcounter
	    endif
  	    @ tmpcounter++
	  end

	  # By getting here we know all locks (apart from $this_thread) have been released.
	  # Remeasure the length of ${instrum}_run_list so we know if any new jobs have since been added
	  set run_ct = `cat ${instrum}_run_list | wc -l`
	  if($DEBUG) echo `datestamp`" $HOSTNAME $procname : All jobs finished and run_ct = $run_ct." | tee -a $LOGFILE
	  if ($run_list_line > $run_ct) then
	    if($DEBUG) echo `datestamp`" $HOSTNAME $procname :		so there are not more jobs to do." | tee -a $LOGFILE
	    rm -f ${THREAD_LOCK}$counter
	    break
	  else
	    if($DEBUG) echo `datestamp`" $HOSTNAME $procname :		so a new retry has been added to the list to be done." | tee -a $LOGFILE
	  endif

	endif

        echo "`datestamp` $HOSTNAME $procname : Start job $run_list_line on thread $this_thread"
        set command_line = `$AWK '(NR=='$run_list_line')' ${instrum}_run_list `

        if ($DEBUG) echo "`datestamp` $HOSTNAME $procname :		$command_line" | tee -a $LOGFILE

	set ii = 2
	while ($ii <= $#command_line)
	  set cli_param = `echo "$command_line[$ii]" | tr "=" " "`
	  #set flag = `echo $command_line[$ii] | cut -d= -f1`
	  #set value = `echo $command_line[$ii] | cut -d= -f2`
	  switch ($cli_param[1])
	    case "--t":
		#echo "File to reduce $cli_param[2]"
		set l1_filename = $cli_param[2]
	    breaksw
	    case "--r":
		#echo "Reference file $cli_param[2]"
		set l1_refname = $cli_param[2]
	    breaksw
	    case "--a":
		set l1_arcname = $cli_param[2]
	    breaksw
	    case "--c":
		set l1_contname = $cli_param[2]
	    breaksw
	    case "--f":
		set flcorname = $cli_param[2]
	    breaksw
	    case "--dir":
		set l2_tempdir = $cli_param[2]
	    breaksw
	    default:
		echo "`datestamp` $HOSTNAME $procname : Unknown command line parameter: param $ii, $command_line[$ii] "
	    breaksw
	  endsw

	  @ ii++
	end
	 
	set l2_filename = `echo $l1_filename | sed 's/_[19]\.fits/_2.fits/'`

	echo thread $this_thread t=$l1_filename r=$l1_refname a=$l1_arcname c=$l1_contname f=$flcorname destination $l2_tempdir/$l2_filename | tee -a $LOGFILE

        # The parallelized command
	# In order to make this thread safe what I actually do is construct a shell script
	# containing all the tests and checks that are required and this gets called like
	# a daughter process. By doing this the variables in that shell do not clash
	# with each other. 
	#
	# It runs the command, read from ${instrum}_run_list
	# Checks the L2 file to make sure it is not empty.
	# If it is empty (naxis=1 in extensions) then
	#   Purge this arc from the list of candidates (${instrum}_l2v2_input_list_1)
	#   Re-run ${instrum}_l2_wrapper_par_sub2 to append a second choice arc to the ${instrum}_run_list
	# We will then continue with the next file in the list. We do not get back to the 
	# second (Nth?) attempt on this file until all others have been tried once.
	# If the fault is in the science frame not the arc we could be here a long long time 
	# trying every available arc file
	#
	# To understand how all this works you need to appreciate a subtlety in how csh expands quoted
	# variables. 
	# Variables in double quotes get resolved here.
	# 	i.e., "$command_line" gets resolved here in sprat_l2v2_wrapper and its value gets written into sprat_tmpscript
	# Variables in single quotes are not resolved. They are purely strings
	# 	i.e., '$status' gets written into sprat_tmpscript as a literal string $status
	echo '#\!/bin/tcsh'											>! ${instrum}_tmpscript$this_thread
	/bin/chmod 777 ${instrum}_tmpscript$this_thread

	# There is an option in l2_exec to clobber an existing outpu directory but we do not currently use it. 
	# Just abort if there is an existing directory.
	echo "if ( -d $l2_tempdir ) then "									>> ${instrum}_tmpscript$this_thread
	echo "  echo Output working directory $l2_tempdir already exisits. Exit. "				>> ${instrum}_tmpscript$this_thread
	echo "  exit "												>> ${instrum}_tmpscript$this_thread
	echo "endif "												>> ${instrum}_tmpscript$this_thread

	# Init.
	echo "source /usr/local/bin/${instrum}_l2_pipeline_debug/scripts/L2_setup"					>> ${instrum}_tmpscript$this_thread
	echo "set erstat = 0"											>> ${instrum}_tmpscript$this_thread

	# Before doing a full run we can check if the reference file will fail
	echo "echo Command to test the ref: $command_line --rc " 						>> ${instrum}_tmpscript$this_thread
	echo "$command_line --rc "			 							>> ${instrum}_tmpscript$this_thread
	echo 'set rc_test = $status'										>> ${instrum}_tmpscript$this_thread
	echo 'echo Result of --rc test was $rc_test'								>> ${instrum}_tmpscript$this_thread
	# We never want to keep the working directory, whether the command succeeded or failed
	echo "if (-d $l2_tempdir) rm -rf $l2_tempdir "							>> ${instrum}_tmpscript$this_thread

	echo 'if ( $rc_test ) then'										>> ${instrum}_tmpscript$this_thread
	echo "    echo Thread=$this_thread. Expunge $l1_refname and choose another ref for $l1_filename "	>> ${instrum}_tmpscript$this_thread
	# Note that we can purge l1_refname from ${instrum}_l2v2_input_list_1 because v_e_ files in that list only ever get used as candidate
	# reference frames. The list of science frames to reduce is separate. Deleting a v_e_ from ${instrum}_l2v2_input_list_1 does not
	# stop it getting reduced.
	echo "    grep -v $l1_refname ${instrum}_l2v2_input_list_1 >! tmp_a.$this_thread "			>> ${instrum}_tmpscript$this_thread
	echo "    mv tmp_a.$this_thread ${instrum}_l2v2_input_list_1 "						>> ${instrum}_tmpscript$this_thread
	echo "    echo 'Thread=$this_thread. $SUB2 $LOGFILE.$this_thread $DEBUG $l1_filename' "			>> ${instrum}_tmpscript$this_thread
	echo "    $SUB2 $this_thread $LOGFILE $DEBUG $l1_filename"						>> ${instrum}_tmpscript$this_thread
	echo "    exit"												>> ${instrum}_tmpscript$this_thread
	echo "endif"												>> ${instrum}_tmpscript$this_thread
	# We only get here if the --rc passed and we know that reference file is good
	#
	# Run the L2
	echo "echo --rc ref test was OK so attempt a reduction"							>> ${instrum}_tmpscript$this_thread
	echo "$command_line >> $LOGFILE.$this_thread " 								>> ${instrum}_tmpscript$this_thread
	# Then assorted data integrity checks to see if it worked
	echo 'set l2_exit_status = $status'									>> ${instrum}_tmpscript$this_thread
	echo '@ erstat += $l2_exit_status '									>> ${instrum}_tmpscript$this_thread
	echo 'if ($erstat == 0 && -d '$l2_tempdir') then'							>> ${instrum}_tmpscript$this_thread
	echo '  cd '$l2_tempdir  										>> ${instrum}_tmpscript$this_thread
	echo "  echo Thread=$this_thread $PWD  "								>> ${instrum}_tmpscript$this_thread
	echo "  if (-s $l2_filename) then"									>> ${instrum}_tmpscript$this_thread
	echo '    set naxis = `'$FGKV '"'$l2_filename'[LSS_NONSS]" NAXIS1 INT `'				>> ${instrum}_tmpscript$this_thread
	echo "    echo Thread=$this_thread. NAXIS1 for $l2_filename is "'$naxis'				>> ${instrum}_tmpscript$this_thread
	echo '    if ("$naxis" == "1") @ erstat ++'								>> ${instrum}_tmpscript$this_thread
	echo "  else"												>> ${instrum}_tmpscript$this_thread
	echo "    @ erstat ++"											>> ${instrum}_tmpscript$this_thread
	echo "  endif"												>> ${instrum}_tmpscript$this_thread
	echo "  cd $WORKING_DIR "										>> ${instrum}_tmpscript$this_thread
	echo "endif"												>> ${instrum}_tmpscript$this_thread
	# And if it did not work, schedule another attempt
	# This will pick a new arc
	echo 'if ($erstat) then'										>> ${instrum}_tmpscript$this_thread
	echo "    echo Thread=$this_thread. Expunge $l1_arcname and choose another arc for $l1_filename "	>> ${instrum}_tmpscript$this_thread
	echo "    grep -v $l1_arcname ${instrum}_l2v2_input_list_1 >! tmp_a.$this_thread "			>> ${instrum}_tmpscript$this_thread
	echo "    mv tmp_a.$this_thread ${instrum}_l2v2_input_list_1 "						>> ${instrum}_tmpscript$this_thread
	if ( -l $l1_arcname ) set l1_arcname = `readlink $l1_arcname `
	echo "    if (-d $l2_tempdir) mv $l2_tempdir ${l2_tempdir}_${l1_arcname:t:r}"				>> ${instrum}_tmpscript$this_thread
	echo "    echo 'Thread=$this_thread. $SUB2 $LOGFILE.$this_thread $DEBUG $l1_filename ' "		>> ${instrum}_tmpscript$this_thread
	echo "    $SUB2 $this_thread $LOGFILE $DEBUG $l1_filename "						>> ${instrum}_tmpscript$this_thread
	echo "else" 												>> ${instrum}_tmpscript$this_thread
	echo "    echo Thread=$this_thread. We believe it worked OK"			 			>> ${instrum}_tmpscript$this_thread
	echo "endif" 												>> ${instrum}_tmpscript$this_thread

	echo " " >> $LOGFILE
	echo "Constructed script ${instrum}_tmpscript$this_thread " >> $LOGFILE
	cat ${instrum}_tmpscript$this_thread >> $LOGFILE
	echo " " >> $LOGFILE

	# From the present script's perspective, the contents of the following ()
	# are what is being called in parallel.
	echo About to run tmpscript and send output to $LOGFILE.$this_thread
	#(source ${instrum}_tmpscript$this_thread ; rm -f ${THREAD_LOCK}$this_thread & ) >> $LOGFILE.$this_thread 
	(./${instrum}_tmpscript$this_thread ; rm -f ${THREAD_LOCK}$this_thread & ) >> $LOGFILE.$this_thread 
	#echo "Using proc number $? $$"
        set counter = 99999 # Arbitrarily large number forces us to jump out of while() once the job has been started 
      else
        @ counter++
        if ($counter > $THREAD_COUNT) then
          # If we have tried all threads, have a small sleep and then start again back at counter = 1
          set counter = 1
          sleep 5
          echo "`datestamp` $HOSTNAME $procname : All $THREAD_COUNT threads are busy. Line $run_list_line of ${instrum}_run_list waiting 30sec." 
        endif
      endif
    end

    set run_ct = `cat ${instrum}_run_list | wc -l`
    echo `datestamp`" $HOSTNAME $procname : run_list_line(job just started) = $run_list_line, run_ct(length of the ${instrum}_run_list) = $run_ct. " |& tee -a $LOGFILE

  end

else
  echo "`datestamp` $HOSTNAME $procname : run_ct appears empty. Nothing to do." |& tee -a $LOGFILE
endif


# Ensure that all threads are complete before proceeding. 
# All this does is open and close every lockfile in order.
# That can only be done once all other jobs have returned.
echo "`datestamp` $HOSTNAME $procname : Waiting for last job to finish" |& tee -a $LOGFILE
set counter = 1
while ( $counter <= $THREAD_COUNT)
  lockfile -s1 ${THREAD_LOCK}$counter
  rm -f ${THREAD_LOCK}$counter
  @ counter++
end



# Clear up the myriad files L2 creates
set CLEAN_UP_L2_FILES = 1
#set CLEAN_UP_L2_FILES = 0
if ($CLEAN_UP_L2_FILES) then
  # There should be a dir for each file created. Get a list of them
  foreach purge_dir (`cat ${instrum}_run_list | sed 's/^.*--t=//' | sed 's/\.fits.*//' | sort | uniq`)
    if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Purge $purge_dir"
    echo "`datestamp` $HOSTNAME $procname : Purge $purge_dir" >> $LOGFILE
    ls -ltr $purge_dir >> $LOGFILE
    set l2_filename = `echo $purge_dir | sed 's/_[19]$/_2/' `

    # First, get the actual L2 FITS output
    if(-e $purge_dir/${l2_filename}.fits ) then
      if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Move ${l2_filename}.fits"
      mv $purge_dir/${l2_filename}.fits .
      #if ( $RED_LEVEL == 9 ) mv ${l2_filename}.fits ${purge_dir}.fits 		# No need for this. Quicklook renames it from _2 to _9 for itself
    else
      if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : No output file ${l2_filename}.fits created. REDUCITON FAILED "
    endif

    # Get the pretty PNG version and convert to JPG
    if(-e $purge_dir/${l2_filename}_spec_output_1.png ) then
      if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : Moving ${l2_filename}_spec_output.png from $purge_dir to ./${l2_filename}.png" >> $LOGFILE
      $MAGICK_CONVERT $purge_dir/${l2_filename}_spec_output_1.png ./${l2_filename}a.jpg 
      $MAGICK_CONVERT $purge_dir/${l2_filename}_spec_output_2.png ./${l2_filename}b.jpg 
      # Quicklook renames it from _2 to _9 for itself
    else 
      if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : There is no ${l2_filename}_spec_output.png in $purge_dir" >> $LOGFILE
      ls -ltr $purge_dir >> $LOGFILE
    endif
    #if(-e $purge_dir/${l2_filename}.jpg ) then
    #  mv $purge_dir/${l2_filename}.jpg .
    #else
    #  if ($DEBUG) echo "`datestamp` $HOSTNAME $procname : No output file ${l2_filename}.png created. No worries. load_archive will create it."
    #endif

    # Read the log file to get diagnostics realting to the aarc fit. This is the min and max wavelength in the 
    # primary image. The min and max in the L2 producst is fixed to be same in every frame, but the derived min and
    # max in the primary image is a useful diagnostic of how much the fit wobbles from frame to frame.
    if (-e ${l2_filename}.fits) then
      set arcfitminmax = `grep -A 12 ${purge_dir}_target_tr_cor.fits ${LOGFILE}.? | grep Inherent | tr "\n" " " | awk '{print $4,$9}'`
      $FAKVC ${l2_filename}.fits L2MINLAM DOUBLE $arcfitminmax[1] "" "Min wavelength in primary image"
      $FAKVC ${l2_filename}.fits L2MAXLAM DOUBLE $arcfitminmax[2] "" "Max wavelength in primary image"
    endif

    # General cleanup
    rm $purge_dir/additional_keys $purge_dir/error_codes
    rm $purge_dir/p_*.dat 
    rm $purge_dir/*.fits
    rm $purge_dir/*.png

    # Delete the working directory. This will only work if it is empty the above has fully cleaned it out
    rmdir $purge_dir
  
  end

  rm ${instrum}_tmpscript?
endif

# Only update the library if this is a full L1 reduction
# Do not do it for RED_LEVEL == 9 quicklook
if ( $RED_LEVEL == 1 ) then

# Generate a list of all the --r reffiles that were attempted and have not been purged from ${instrum}_run_list. I.e., they worked
if ( -e candidate_library_reflist ) rm candidate_library_reflist
foreach tf ( `cat ${instrum}_run_list | sed 's/^.*--r=//' | sed 's/\.fits.*//' | sort | uniq ` )
  grep $tf ${instrum}_l2v2_input_list_1 >> candidate_library_reflist
end

## Generate a list of all the --a arcfiles that were attempted and have not been purged from ${instrum}_run_list. I.e., they worked
#if ( -e candidate_library_arclist ) rm candidate_library_arclist
#foreach tf ( `cat ${instrum}_run_list | sed 's/^.*--a=//' | sed 's/\.fits.*//' | sort | uniq ` )
#  grep $tf ${instrum}_l2v2_input_list_1 >> candidate_library_arclist
#end

# Find the most recent 
#	arc 
#	ref files which were actually used successfully today
# and put it in the library ready for tomorrow in case no one takes any arcs tomorrow.
# Note that any arcs which failed in the L2 pipeline have already been deleted from ${instrum}_l2v2_input_list_1
foreach libtype (arc reference) 
  foreach gratset (blue red)
    foreach binning (1 2)

      if ( $libtype == "arc" ) then
        # ${instrum}_l2v2_input_list_1 contains all the arcs, whether used or not
        set lastfile = `$AWK '(/^'$letter'_a/ && $9=="Xe" && $2=="'$gratset'" && $8=='$binning' )' ${instrum}_l2v2_input_list_1 | sort -k 4 | tail -1 | $AWK '{print $1}' `
	set library_filename = ${DPRT_BASEDIR}/${instrum}/Arc/${letter}_xearc_${gratset}_${binning}.fits
	set LIBDIR = Arc
      else if ( $libtype == "reference" ) then
        set lastfile = `$AWK '(/^'$letter'_[es]/ && $9=="-"  && $2=="'$gratset'" && $8=='$binning' )' candidate_library_reflist    | sort -k 4 | tail -1 | $AWK '{print $1}' `
	set library_filename = ${DPRT_BASEDIR}/${instrum}/Reference/${letter}_reference_${gratset}_${binning}.fits
	set LIBDIR = Reference
      endif
      echo "`datestamp` $HOSTNAME $procname : last file of type $libtype = $lastfile " >> $LOGFILE

      if ("$lastfile" != "") then

	# Get rid of the old library file
	if (-l $library_filename ) then
	  set old_file = `readlink $library_filename `
	  if (-e $old_file) rm -f $old_file
          echo "`datestamp` $HOSTNAME $procname : Purged the old library ${gratset}_${binning}.fits $libtype $old_file." >> $LOGFILE
	endif

        cp -f $lastfile  ${DPRT_BASEDIR}/${instrum}/$LIBDIR/.
        echo "`datestamp` $HOSTNAME $procname : Put $lastfile in library as the new $gratset binning $binning $libtype." >> $LOGFILE

	# Create a link from the new FITS to the generic format filename
	# First delete it if it either exists or is a broken link
	if ( -e $library_filename ) rm $library_filename 
	if ( -l $library_filename ) rm $library_filename
	ln -s ${DPRT_BASEDIR}/${instrum}/${LIBDIR}/$lastfile $library_filename 
        echo "`datestamp` $HOSTNAME $procname : 	and linked it to ${library_filename:t} " >> $LOGFILE
      else
        echo "`datestamp` $HOSTNAME $procname : No new $gratset binning $binning $libtype to add to the library" >> $LOGFILE
      endif

    end
  end
end
rm candidate_library_reflist

endif 		# end of if ( $RED_LEVEL == 1 )

# Delete the temp files
# This script's own internal temp files. The myriad files created by the L2 pipeline itself
# should already have been cleaned up earlier.
set nn = 1
while ($nn <= $THREAD_COUNT)
  if (-e ${instrum}_wlamp_shortlist_$nn) rm -f ${instrum}_wlamp_shortlist_$nn
  if (-e ${instrum}_ref_shortlist_$nn) rm -f ${instrum}_ref_shortlist_$nn
  if (-e ${instrum}_arc_shortlist_$nn) rm -f ${instrum}_arc_shortlist_$nn
  @ nn++
end

if (-e ${instrum}_spec_list) rm -f ${instrum}_spec_list
if (-e ${instrum}_arc_list) rm -f ${instrum}_arc_list

if ( ( $DEBUG == 0 ) && ( -e ${instrum}_l2v2_input_list_1 ) ) rm -f ${instrum}_l2v2_input_list_1
echo "`datestamp` $HOSTNAME $procname : Final version of run_list at the very end, showing all the retries:" >> $LOGFILE
cat ${instrum}_run_list >> $LOGFILE
if ( ( $DEBUG == 0 ) && ( -e ${instrum}_run_list ) ) rm -f ${instrum}_run_list

if (-e ${instrum}_arc_shortlist) rm -f ${instrum}_arc_shortlist
set counter = 1
while ($counter <= $THREAD_COUNT)
  if (-e ${instrum}_arc_shortlist_${THREAD_COUNT}) rm -f ${instrum}_arc_shortlist_${THREAD_COUNT}
  if (-e ${instrum}_wlamp_shortlist_${THREAD_COUNT}) rm -f ${instrum}_wlamp_shortlist_${THREAD_COUNT}
  @ counter++
end


cleanup:
# The master logfile from this script is in $LOGFILE
# The logs output by the L2 pipeline are in $LOGFILE.N
# Cat the all together into a single file
set counter = 1
echo "#" >> $LOGFILE
echo "# End of wrapper logging " >> $LOGFILE
echo "#" >> $LOGFILE
echo " " >> $LOGFILE
while ( $counter <= $THREAD_COUNT)
  if (-e ${LOGFILE}.$counter) then
    echo "#" >> $LOGFILE
    echo "# Start of L2 pipeline logging from thread $counter " >> $LOGFILE
    echo "#" >> $LOGFILE
    cat ${LOGFILE}.$counter >> $LOGFILE
    echo "#" >> $LOGFILE
    echo "# End of L2 pipeline logging from thread $counter " >> $LOGFILE
    echo "#" >> $LOGFILE
    echo " " >> $LOGFILE
    rm ${LOGFILE}.$counter
  endif
  @ counter++
end
if ( $RED_LEVEL == 1 ) then
  mv $LOGFILE /data/logs/Daily_Reduction_logs/sprat/. 
  if ($DEBUG) echo Log file has gone to /data/logs/Daily_Reduction_logs/sprat/ 
  gzip /data/logs/Daily_Reduction_logs/sprat/$LOGFILE
endif


if (-e $lock) then
    /bin/rm -f $lock
    set erstat = $status
    if ($erstat == 0) then
        echo `datestamp` $HOSTNAME $procname : Removed lockfile
    else
        echo "`datestamp` $HOSTNAME $procname : Warning: Unable to remove lockfile: $lock"
	echo "`datestamp` $HOSTNAME $procname :     rm exit status = $erstat "
    endif
else
    echo "`datestamp` $HOSTNAME $procname : Warning: Lockfile $lock was not found "
endif

if ($exit_value == 99) then
  echo "Using killall to stop any running frodo_l2v2_wrapper_par.csh processes, including myself!"
  killall sprat_l2v2_wrapper_par_retry.csh
else 
  exit $exit_value
endif




unknown_error:
set exit_value = 99
echo "Using killall to stop any running sprat_L2 processes"
echo "Though unlikely, it is theoretically possible that some other legitimate copy was running and this will ruin it."
echo ""
# I am not sure if this works. L2_exec.py is not invoked as an executable. It appears in a ps as "python L2_exec.py"
killall L2_exec.py
goto cleanup


